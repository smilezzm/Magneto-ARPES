# -*- coding: utf-8 -*-
"""MagnetoARPES_250818_Mengyao.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o9P9uazz-n2HfmxCCNIxBzKJMocbGcLp
"""

##250818 - Add angle plot
#To-do list : Consider coil tilted / Consider sample not perfectly normal

# ------ Edited by Mengyao on 2025.9.1 ------
# Generally: Make its function the same as matlab codes at 
# Specifically:
#   Take into account the translation and rotation of the coil relative to the sample
#   Get the backward mapping based on 2D interpolation, so that given (Ekin, vx, vy) and the field, one can obtain corresponding emitting (vx0, vy0)
# ------ Edited by Mengyao on 2025.9.1 ------

import numpy as np
import matplotlib.pyplot as plt
from scipy.special import ellipk, ellipe
from scipy.interpolate import RegularGridInterpolator
from mpl_toolkits.mplot3d import Axes3D  # 필요
import time
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# ----------------------------
# Constants & Setup
# ----------------------------
e  = 1.602e-19
m  = 9.109e-31
hbar = 1.055e-34

hv   = 115
phi  = 4.29
E_B  = 0.0
Ekin = (hv - phi - E_B) * e
v0   = np.sqrt(2*Ekin/m)

L_flight = 0.038  # m

# ----------------------------
# Solenoid params
# ----------------------------

# # Homelab new devices
# coil_inner_d = 6.3e-3
# coil_outer_d = 10e-3
# coil_height  = 7e-3

# Soleil Dev C&D
coil_inner_d = 6.3e-3
coil_outer_d = 12e-3
coil_height  = 5.6e-3


wire_d       = 0.165e-3

I            = 0.2   # 전류, A단위

mu0 = 4*np.pi*1e-7

R_inner = coil_inner_d/2
R_outer = coil_outer_d/2
z_start = -coil_height
z_end   = 0.0

n_r = int(np.floor((R_outer-R_inner)/wire_d))
n_z = int(np.floor(coil_height/wire_d))
total_turns = n_r * n_z
print("n_r (layers) =", n_r, " n_z (turns per layer) =", n_z, " total turns =", total_turns)

rr = np.linspace(R_inner + wire_d/2, R_outer - wire_d/2, n_r)
zz = np.linspace(z_start + wire_d/2, z_end - wire_d/2, n_z)

# ----------------------------
# Analytic 3D B-field using elliptic integrals
# ----------------------------
def bfield_loop_offaxis(x, y, z, a, I):
    x = np.atleast_1d(x).astype(float)
    y = np.atleast_1d(y).astype(float)
    z = np.atleast_1d(z).astype(float)

    rho = np.sqrt(x**2 + y**2)
    B_rho = np.zeros_like(rho)
    B_z   = np.zeros_like(rho)

    mask_rho_pos = (rho > 0)
    mask_rho_zero = ~mask_rho_pos

    if np.any(mask_rho_pos): # off-axis, elliptical integration
        rp = rho[mask_rho_pos]
        zp = z[mask_rho_pos]
        num = 4 * a * rp
        denom = (a + rp)**2 + zp**2
        k2 = np.clip(num / denom, 0.0, 1.0-1e-12)
        K = ellipk(k2)
        E = ellipe(k2)
        common = np.sqrt(denom)
        term1 = -K
        term2 = (a*a + rp*rp + zp*zp) / ((a - rp)**2 + zp**2) * E
        B_rho_p = (mu0 * I)/(2*np.pi) * (zp / (rp*common)) * (term1 + term2)
        term3 = K
        term4 = (a*a - rp*rp - zp*zp)/((a-rp)**2 + zp**2) * E
        B_z_p = (mu0 * I)/(2*np.pi*common) * (term3 + term4)
        B_rho[mask_rho_pos] = B_rho_p
        B_z[mask_rho_pos] = B_z_p

    if np.any(mask_rho_zero): # on-axis
        zz_axis = z[mask_rho_zero]
        B_z_axis = (mu0*I*a**2)/(2*(a**2+zz_axis**2)**1.5)
        B_z[mask_rho_zero] = B_z_axis
        B_rho[mask_rho_zero] = 0.0

    Bx = np.zeros_like(B_rho)
    By = np.zeros_like(B_rho)
    mask = (rho > 0)
    Bx[mask] = B_rho[mask] * (x[mask]/rho[mask])
    By[mask] = B_rho[mask] * (y[mask]/rho[mask])
    return Bx, By, B_z

def bfield_solenoid_ellip(x, y, z, rr, zz, I):
    x = np.atleast_1d(x).astype(float)
    y = np.atleast_1d(y).astype(float)
    z = np.atleast_1d(z).astype(float)
    Bx = np.zeros_like(x)
    By = np.zeros_like(y)
    Bz = np.zeros_like(z)
    for R_loop in rr:
        for z_loop in zz:
            bx, by, bz = bfield_loop_offaxis(x, y, z - z_loop, R_loop, I)
            Bx += bx
            By += by
            Bz += bz
    return np.stack([Bx, By, Bz], axis=-1)

# ----------------------------
# B-field Interpolation grid
# ----------------------------
x_vals = np.linspace(-0.05,0.05,21)
y_vals = np.linspace(-0.05,0.05,21)
z_vals = np.linspace(0.0,L_flight,21)
X,Y,Z = np.meshgrid(x_vals,y_vals,z_vals,indexing='ij')

print("Calculating 3D B-field grid (elliptic integral)...")
B_grid = bfield_solenoid_ellip(X,Y,Z,rr,zz,I)
B_interp = RegularGridInterpolator((x_vals,y_vals,z_vals),B_grid)

# Central B-field
B_center = B_interp([[0.0,0.0,0.0]])[0]
B_mag_center = np.linalg.norm(B_center)

B_center_analyzer = B_interp([[0.0,0.0,L_flight]])[0]
B_mag_center_analzyer = np.linalg.norm(B_center_analyzer)

theta_rad = e*B_mag_center*L_flight/(m*v0)
theta_deg = np.degrees(theta_rad)
print(f"B-field at center z=0: {B_mag_center*1e3:.3f} mT")
print(f"B-field at center z=38mm: {B_mag_center_analzyer*1e3:.3f} mT")
#print(f"Approx Fermi electron rotation: {theta_deg:.2f} deg")

# ----------------------------
# Initial k-grid (Å^-1)
# ----------------------------
grid_points = 10
kx_vals = np.linspace(-1.0,1.0,grid_points)*1e10
ky_vals = np.linspace(-1.0,1.0,grid_points)*1e10
kx0, ky0 = np.meshgrid(kx_vals, ky_vals)
kF = m*v0/hbar
kz2 = kF**2 - kx0**2 - ky0**2
kz0 = np.where(kz2>=0, np.sqrt(kz2), np.nan)

x0 = np.zeros_like(kx0)
y0 = np.zeros_like(ky0)
z0 = np.zeros_like(kx0)
vx0 = hbar*kx0/m
vy0 = hbar*ky0/m
vz0 = hbar*kz0/m
pos0 = np.stack([x0,y0,z0],axis=-1)
vel0 = np.stack([vx0,vy0,vz0],axis=-1)
valid = ~np.isnan(vz0)

# ----------------------------
# Boris pusher
# ----------------------------
def boris_push(r, v, q, m, dt):
    B = B_interp([r])[0]
    t = (q*B/m)*0.5*dt
    t_mag2 = np.dot(t,t)
    s = 2*t/(1+t_mag2)
    v_minus = v
    v_prime = v_minus + np.cross(v_minus,t)
    v_plus = v_minus + np.cross(v_prime,s)
    v_new = v_plus
    r_new = r + v_new*dt
    return r_new, v_new


# ----------------------------
# Time stepping
# ----------------------------
B_avg = B_mag_center
omega_c = e*B_avg/m
T_c = 2*np.pi/omega_c
steps_per_T = 100 # Reverted to original value
dt = T_c/steps_per_T # time step size for boris pusher calculation

n_steps = int(np.ceil(L_flight / v0 / dt))
print(f"dt={dt:.3e}, n_steps needed for normal emission electrons~{n_steps}") # for reference to choose max_sim_steps below

# Use a large fixed number of simulation steps per trajectory (should be larger than n_steps above)
# This ensures particles have enough time to reach L_flight even if their z-velocity is low
max_sim_steps = 400 # Enter steps you want to use for this simulation

print(f"dt={dt:.3e}, max_sim_steps={max_sim_steps}")

final_pos = np.full_like(pos0,np.nan)
final_vel = np.full_like(vel0,np.nan)
start = time.time()

track_i = grid_points//2
track_j = grid_points//2
traj_r = []

for i in range(grid_points):
    for j in range(grid_points):
        if not valid[i,j]:
            continue
        r = pos0[i,j].copy().astype(float)
        v = vel0[i,j].copy().astype(float)
        # Use a fixed large number of steps for simulation
        for n in range(max_sim_steps): # Use the fixed large step limit
            r, v = boris_push(r,v,-e,m,dt)
            if (i==track_i) and (j==track_j) and (n%10==0):
                traj_r.append(r.copy())
            if r[2]>=L_flight:
                break
        # Only record final position/velocity if the particle reached L_flight
        if r[2]>=L_flight:
            final_pos[i,j] = r
            final_vel[i,j] = v
elapsed = time.time() - start
print(f"Elapsed: {elapsed:.1f} s")

# # ----------------------------
# # k-space mapping plot
# # ----------------------------
# final_kx = m*final_vel[...,0]/hbar/1e10
# final_ky = m*final_vel[...,1]/hbar/1e10
# initial_kx = kx0/1e10
# initial_ky = ky0/1e10

# plt.figure(figsize=(7,7))
# plt.scatter(initial_kx, initial_ky, s=20, c='0.6', marker='o', label='Initial k (B=0)')
# mask = np.isfinite(final_kx) & np.isfinite(final_ky)
# plt.scatter(final_kx[mask], final_ky[mask], s=40, c='blue', marker='^', label='Final k (B-field)')
# plt.xlabel(r'$k_x\ (\mathrm{\AA^{-1}})$')
# plt.ylabel(r'$k_y\ (\mathrm{\AA^{-1}})$')
# plt.title(f'ARPES k-space mapping under solenoid B-field\nCoil: d_in={coil_inner_d*1e3:.1f}mm, d_out={coil_outer_d*1e3:.1f}mm, h={coil_height*1e3:.1f}mm, Turns={total_turns}, I={I:.2f}A\nB(z=0)={B_mag_center*1e3:.3f} mT')
# plt.grid(True)
# plt.legend()
# plt.gca().set_aspect('equal')
# plt.tight_layout()
# plt.show()

# ----------------------------
# k-space mapping with arrows and rotation angle and distance change
# ----------------------------
final_kx = m*final_vel[...,0]/hbar/1e10
final_ky = m*final_vel[...,1]/hbar/1e10
initial_kx = kx0/1e10
initial_ky = ky0/1e10

plt.figure(figsize=(8,8))
mask = np.isfinite(final_kx) & np.isfinite(final_ky)

for i in range(grid_points):
    for j in range(grid_points):
        if mask[i,j]:
            b0 = initial_kx[i,j] # Using kx, ky as 'beta', 'alpha' for distance calculation
            a0 = initial_ky[i,j]
            bf = final_kx[i,j]
            af = final_ky[i,j]

            dx = bf - b0
            dy = af - a0

            plt.arrow(b0, a0, dx, dy,
                      head_width=0.02, head_length=0.02,
                      fc='blue', ec='blue', alpha=0.5)

            # coil-axis 중심 기준 회전각 & 거리 변화율
            u = np.array([b0, a0])
            v = np.array([bf, af])
            if np.linalg.norm(u) > 1e-6 and np.linalg.norm(v) > 1e-6:
                cosang = np.clip(np.dot(u, v) / (np.linalg.norm(u)*np.linalg.norm(v)), -1, 1)
                rot_angle_deg = np.degrees(np.arccos(cosang))
            else:
                rot_angle_deg = 0.0

            r0 = np.linalg.norm(u)
            rf = np.linalg.norm(v)
            dr_percent = (rf - r0) / r0 * 100 if r0 > 1e-6 else 0.0

            plt.text(b0 + dx*0.5, a0 + dy*0.5,
                     f'{rot_angle_deg:.1f}°\n{dr_percent:+.1f}%',
                     fontsize=6, color='red', alpha=0.7,
                     ha='center', va='center') # Center text on the arrow

plt.scatter(initial_kx, initial_ky, s=20, c='0.6', marker='o', label='Initial k (B=0)')
plt.xlabel(r'$k_x\ (\mathrm{\AA^{-1}})$')
plt.ylabel(r'$k_y\ (\mathrm{\AA^{-1}})$')
plt.title(f'ARPES k-space mapping under solenoid B-field\n(Arrows with local rotation Δ and distance change %)\nCoil ID, OD, height ={coil_inner_d*1e3:.1f}, {coil_outer_d*1e3:.1f}, {coil_height*1e3:.1f} mm, Turns={total_turns}, I={I:.2f}A\nhv = {hv:.1f}eV, B(z=0)={B_mag_center*1e3:.3f} mT')
plt.grid(True)
plt.gca().set_aspect('equal')
plt.tight_layout()
plt.show()

# ============================================================
# Beta-Alpha mapping with arrows + local rotation angle (slit along y/ky)
# ============================================================
beta_range = np.radians(np.linspace(-15, 15, 16))   # xz-plane angle -> kx
alpha_range = np.radians(np.linspace(-15, 15, 16))  # yz-plane angle -> ky
Beta, Alpha = np.meshgrid(beta_range, alpha_range)

# Initial k-vectors (B=0) using new projection-angle definition
kz_i = kF / np.sqrt(1 + np.tan(Beta)**2 + np.tan(Alpha)**2)
kx_i = kz_i * np.tan(Beta)
ky_i = kz_i * np.tan(Alpha)

vx_i = hbar * kx_i / m
vy_i = hbar * ky_i / m
vz_i = hbar * kz_i / m

# Containers for final angles
final_beta_B = np.full_like(Beta, np.nan)
final_alpha_B = np.full_like(Alpha, np.nan)

# Use the same large fixed number of simulation steps for Beta-Alpha mapping
max_sim_steps_beta_alpha = max_sim_steps # Use the same large step limit

print("Tracing Beta-Alpha grid with B-field (slit along y)...")
for i in range(Beta.shape[0]):
    for j in range(Beta.shape[1]):
        r = np.array([0.0, 0.0, 0.0], dtype=float)
        v = np.array([vx_i[i,j], vy_i[i,j], vz_i[i,j]], dtype=float)
        if np.isnan(v[2]):
            continue
        # Use a fixed large number of steps for simulation
        for n in range(max_sim_steps_beta_alpha): # Use the fixed large step limit
            r, v = boris_push(r, v, -e, m, dt)
            if r[2] >= L_flight:
                break
        # Only record final position/velocity if the particle reached L_flight
        if r[2] >= L_flight:
            v_norm = np.linalg.norm(v)
            if v_norm > 0:
                beta_f  = np.degrees(np.arcsin(v[0]/v_norm))  # kx / xz-plane
                alpha_f = np.degrees(np.arcsin(v[1]/v_norm))  # ky / yz-plane
                final_beta_B[i,j] = beta_f
                final_alpha_B[i,j] = alpha_f

# ----------------------------
# Plot: Beta-Alpha mapping with arrows + rotation angle labels
plt.figure(figsize=(9,8))
mask = np.isfinite(final_beta_B) & np.isfinite(final_alpha_B)

for i in range(Beta.shape[0]):
    for j in range(Beta.shape[1]):
        if mask[i,j]:
            b0 = np.degrees(Beta[i,j])
            a0 = np.degrees(Alpha[i,j])
            bf = final_beta_B[i,j]
            af = final_alpha_B[i,j]
            db = bf - b0
            da = af - a0

            plt.arrow(b0, a0, db, da,
                      head_width=0.5, head_length=0.5,
                      fc='blue', ec='blue', alpha=0.6,
                      length_includes_head=True)

            # coil-axis 중심 기준 회전각 & 거리 변화율
            u = np.array([b0, a0])
            v = np.array([bf, af])
            if np.linalg.norm(u) > 1e-6 and np.linalg.norm(v) > 1e-6:
                cosang = np.clip(np.dot(u, v) / (np.linalg.norm(u)*np.linalg.norm(v)), -1, 1)
                rot_angle_deg = np.degrees(np.arccos(cosang))
            else:
                rot_angle_deg = 0.0

            r0 = np.linalg.norm(u)
            rf = np.linalg.norm(v)
            dr_percent = (rf - r0) / r0 * 100 if r0 > 1e-6 else 0.0

            plt.text(b0 + db*0.5, a0 + da*0.5,
                     f'{rot_angle_deg:.1f}°\n{dr_percent:+.1f}%',
                     fontsize=6, color='red', alpha=0.7,
                     ha='center', va='center') # Center text on the arrow

plt.scatter(np.degrees(Beta), np.degrees(Alpha),
            s=20, c='0.6', marker='o', label='Initial (B=0)')

plt.xlabel(r'$\beta\ (\mathrm{deg})$ [xz-plane, //k_x, Deflection angle]')
plt.ylabel(r'$\alpha\ (\mathrm{deg})$ [yz-plane, //k_y, along vetical slit]')
plt.title(f'Beta-Alpha mapping under solenoid B-field\n(Arrows with local rotation Δ, slit along y and distance change %)\nCoil ID, OD, height ={coil_inner_d*1e3:.1f}, {coil_outer_d*1e3:.1f}, {coil_height*1e3:.1f} mm, Turns={total_turns}, I={I:.2f}A\nhv = {hv:.1f}eV, B(z=0)={B_mag_center*1e3:.3f} mT')
plt.grid(True)
plt.gca().set_aspect('equal')
plt.xlim([-15,15])
plt.ylim([-15,15])
plt.legend(loc='upper right')
plt.tight_layout()
plt.show()

# ----------------------------
# Representative 3D trajectories with B-field arrows and XY projection
# ----------------------------

angles_deg = [3, 5, 10, 15]
angles_rad = [np.radians(a) for a in angles_deg]

n_steps_traj = 500
dt_traj = L_flight / (v0 * n_steps_traj)

# 두 개 subplot: 왼쪽은 3D, 오른쪽은 2D
fig = make_subplots(
    rows=1, cols=2,
    specs=[[{"type": "scene"}, {"type": "xy"}]],
    subplot_titles=("3D Electron trajectories", "Top view (XY projection)")
)

for theta in angles_rad:
    vx = v0 * np.sin(theta)
    vy = 0.0
    vz = v0 * np.cos(theta)
    r = np.array([0.0, 0.0, 0.0])
    v = np.array([vx, vy, vz])

    traj_B = [r.copy()]
    for n in range(n_steps_traj): # Reverted to original n_steps_traj for visualization
        r, v = boris_push(r, v, -e, m, dt_traj)
        traj_B.append(r.copy())
        if r[2]>=L_flight:
            break
    traj_B = np.array(traj_B)

    # 3D Trajectory
    fig.add_trace(
        go.Scatter3d(
            x=traj_B[:,0]*1e3,
            y=traj_B[:,1]*1e3,
            z=traj_B[:,2]*1e3,
            mode='lines',
            line=dict(width=4),
            name=f'{np.degrees(theta):.0f}° θ'
        ),
        row=1, col=1
    )

    # XY Projection
    fig.add_trace(
        go.Scatter(
            x=traj_B[:,0]*1e3,
            y=traj_B[:,1]*1e3,
            mode='lines',
            line=dict(width=2),
            name=f'{np.degrees(theta):.0f}° θ',
            showlegend=False  # 범례는 왼쪽만
        ),
        row=1, col=2
    )

# Layout 설정
fig.update_layout(
    scene=dict(
        xaxis_title='x (mm)',
        yaxis_title='y (mm)',
        zaxis_title='z (mm)'
    ),
    xaxis2=dict(title='x (mm)', scaleanchor="y2"),
    yaxis2=dict(title='y (mm)'),
    title=f"Electron trajectories (3D and XY projection)<br><sup>\nCoil ID, OD, height ={coil_inner_d*1e3:.1f}, {coil_outer_d*1e3:.1f}, {coil_height*1e3:.1f} mm, Turns={total_turns}, I={I:.2f}A\nhv = {hv:.1f}eV, B(z=0)={B_mag_center*1e3:.3f} mT'</sup>",
    width=1000, height=500
)

fig.show()